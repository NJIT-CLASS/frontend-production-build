import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _extends from 'babel-runtime/helpers/extends';
import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
/**
 * @copyright   2016, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 * 
 */

import React from 'react';
import Element from './Element';
import { FILTER_DENY, FILTER_CAST_NUMBER, FILTER_CAST_BOOL, TAGS, TAGS_BLACKLIST, ATTRIBUTES, ATTRIBUTES_TO_PROPS, TYPE_INLINE, TYPE_BLOCK, CONFIG_BLOCK } from './constants';

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var INVALID_ROOTS = ['!DOC', 'HTML', 'HEAD', 'BODY'];
var ROOT_COMPARE_LENGTH = 4;
var ARIA_COMPARE_LENGTH = 5;

var Parser = function () {
  function Parser(markup) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var filters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

    _classCallCheck(this, Parser);

    if (!markup) {
      markup = '';
    } else if (typeof markup !== 'string') {
      if ("production" !== process.env.NODE_ENV) {
        throw new TypeError('Interweave parser requires a valid string.');
      }
    }

    this.props = props;
    this.matchers = matchers;
    this.filters = filters;
    this.keyIndex = -1;
    this.doc = this.createDocument(markup);
  }

  _createClass(Parser, [{
    key: 'applyAttributeFilters',
    value: function applyAttributeFilters(name, value) {
      return this.filters.reduce(function (nextValue, filter) {
        if (typeof filter.attribute === 'function') {
          return filter.attribute(name, nextValue);
        }

        return nextValue;
      }, value);
    }
  }, {
    key: 'applyNodeFilters',
    value: function applyNodeFilters(name, node) {
      return this.filters.reduce(function (nextNode, filter) {
        if (nextNode && typeof filter.node === 'function') {
          return filter.node(name, nextNode);
        }

        return nextNode;
      }, node);
    }
  }, {
    key: 'applyMatchers',
    value: function applyMatchers(string, parentConfig) {
      var _this = this;

      var elements = [];
      var props = this.props;

      var matchedString = string;
      var parts = {};

      this.matchers.forEach(function (matcher) {
        var tagName = matcher.asTag().toLowerCase();
        var config = _this.getTagConfig(tagName);

        if (props[matcher.inverseName] || TAGS_BLACKLIST[tagName] || !props.disableWhitelist && !TAGS[tagName]) {
          return;
        }

        if (!_this.canRenderChild(parentConfig, config)) {
          return;
        }

        while (parts = matcher.match(matchedString)) {
          var _parts = parts,
              match = _parts.match,
              partProps = _objectWithoutProperties(_parts, ['match']);

          matchedString = matchedString.replace(match, '#{{' + elements.length + '}}#');

          _this.keyIndex += 1;

          elements.push(matcher.createElement(match, _extends({}, props, partProps, {
            key: _this.keyIndex
          })));
        }
      });

      if (elements.length === 0) {
        return matchedString;
      }

      var matchedArray = [];
      var lastIndex = 0;

      while (parts = matchedString.match(/#\{\{(\d+)\}\}#/)) {
        var _parts2 = parts,
            _parts3 = _slicedToArray(_parts2, 2),
            no = _parts3[1];

        var _parts4 = parts,
            index = _parts4.index;

        if (lastIndex !== index) {
          matchedArray.push(matchedString.slice(lastIndex, index));
        }

        matchedArray.push(elements[parseInt(no, 10)]);

        lastIndex = index + parts[0].length;

        matchedString = matchedString.replace('#{{' + no + '}}#', '%{{' + no + '}}%');
      }

      if (lastIndex < matchedString.length) {
        matchedArray.push(matchedString.slice(lastIndex));
      }

      return matchedArray;
    }
  }, {
    key: 'canRenderChild',
    value: function canRenderChild(parentConfig, childConfig) {
      if (!parentConfig.tagName || !childConfig.tagName) {
        return false;
      }

      if (parentConfig.children && parentConfig.children.length > 0 && parentConfig.children.indexOf(childConfig.tagName) === -1) {
        return false;
      }

      if (childConfig.parent && childConfig.parent.length > 0 && childConfig.parent.indexOf(parentConfig.tagName) === -1) {
        return false;
      }

      if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {
        return false;
      }

      if (!parentConfig.block && childConfig.type === TYPE_BLOCK) {
        return false;
      }

      if (!parentConfig.inline && childConfig.type === TYPE_INLINE) {
        return false;
      }

      return true;
    }
  }, {
    key: 'convertLineBreaks',
    value: function convertLineBreaks(markup) {
      var _props = this.props,
          noHtml = _props.noHtml,
          noHtmlExceptMatchers = _props.noHtmlExceptMatchers,
          disableLineBreaks = _props.disableLineBreaks;


      if (noHtml || noHtmlExceptMatchers || disableLineBreaks || markup.match(/<((?:\/[a-z ]+)|(?:[a-z ]+\/))>/ig)) {
        return markup;
      }

      var nextMarkup = markup.replace(/\r\n/g, '\n');

      nextMarkup = nextMarkup.replace(/\n{3,}/g, '\n\n\n');

      nextMarkup = nextMarkup.replace(/\n/g, '<br/>');

      return nextMarkup;
    }
  }, {
    key: 'createDocument',
    value: function createDocument(markup) {
      var doc = document.implementation.createHTMLDocument('Interweave');

      if (INVALID_ROOTS.indexOf(markup.substr(1, ROOT_COMPARE_LENGTH).toUpperCase()) >= 0) {
        if ("production" !== process.env.NODE_ENV) {
          throw new Error('HTML documents as Interweave content are not supported.');
        }
      } else {
        doc.body.innerHTML = this.convertLineBreaks(markup);
      }

      return doc;
    }
  }, {
    key: 'extractAttributes',
    value: function extractAttributes(node) {
      var _this2 = this;

      var disableWhitelist = this.props.disableWhitelist;

      var attributes = {};
      var count = 0;

      if (node.nodeType !== ELEMENT_NODE || !node.attributes) {
        return null;
      }

      Array.from(node.attributes).forEach(function (attr) {
        var name = attr.name,
            value = attr.value;

        var filter = ATTRIBUTES[name];

        name = name.toLowerCase();

        if (!_this2.isSafe(node)) {
          return;
        }

        if (name.slice(0, ARIA_COMPARE_LENGTH) !== 'aria-') {
          if (!disableWhitelist && (!filter || filter === FILTER_DENY) || name.match(/^on/) || value.replace(/(\s|\0|&#x0(9|A|D);)/, '').match(/(javascript|vbscript|livescript|xss):/i)) {
            return;
          }
        }

        value = _this2.applyAttributeFilters(name, value);

        if (filter === FILTER_CAST_BOOL) {
          value = value === 'true' || value === name;
        } else if (filter === FILTER_CAST_NUMBER) {
          value = parseFloat(value);
        } else {
          value = String(value);
        }

        attributes[ATTRIBUTES_TO_PROPS[name] || name] = value;
        count += 1;
      });

      if (count === 0) {
        return null;
      }

      return attributes;
    }
  }, {
    key: 'getTagConfig',
    value: function getTagConfig(tagName) {
      if (TAGS[tagName]) {
        return _extends({}, TAGS[tagName], {
          tagName: tagName
        });
      }

      return {};
    }
  }, {
    key: 'isSafe',
    value: function isSafe(node) {
      if (!(node instanceof HTMLElement)) {
        return true;
      }

      if ('href' in node) {
        var href = node.getAttribute('href');

        if (href && href.charAt(0) === '#') {
          return true;
        }

        var protocol = (node.protocol || '').toLowerCase();

        return protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:';
      }

      return true;
    }
  }, {
    key: 'parse',
    value: function parse() {
      return this.parseNode(this.doc.body, _extends({}, CONFIG_BLOCK, {
        tagName: 'body'
      }));
    }
  }, {
    key: 'parseNode',
    value: function parseNode(parentNode, parentConfig) {
      var _this3 = this;

      var _props2 = this.props,
          commonClass = _props2.commonClass,
          noHtml = _props2.noHtml,
          noHtmlExceptMatchers = _props2.noHtmlExceptMatchers,
          disableWhitelist = _props2.disableWhitelist,
          transform = _props2.transform;

      var content = [];
      var mergedText = '';

      Array.from(parentNode.childNodes).forEach(function (node) {
        if (node.nodeType === ELEMENT_NODE) {
          var tagName = node.nodeName.toLowerCase();
          var config = _this3.getTagConfig(tagName);

          if (TAGS_BLACKLIST[tagName]) {
            return;
          }

          if (mergedText) {
            content.push(mergedText);
            mergedText = '';
          }

          var nextNode = _this3.applyNodeFilters(tagName, node);

          if (!nextNode) {
            return;
          }

          var children = void 0;
          if (transform) {
            _this3.keyIndex += 1;
            var _key = _this3.keyIndex;
            children = _this3.parseNode(nextNode, config);

            var transformed = transform(nextNode, children, config);
            if (transformed === null) {
              return;
            } else if (typeof transformed !== 'undefined') {
              var transformedWithKey = React.cloneElement(transformed, { key: _key });
              content.push(transformedWithKey);
              return;
            }

            _this3.keyIndex = _key - 1;
          }

          if (!(noHtml || noHtmlExceptMatchers) && (disableWhitelist || _this3.canRenderChild(parentConfig, config))) {
            _this3.keyIndex += 1;

            var attributes = _this3.extractAttributes(nextNode);
            var elementProps = {
              key: _this3.keyIndex,
              tagName: tagName,
              commonClass: commonClass
            };

            if (attributes) {
              elementProps.attributes = attributes;
            }

            if (config.void) {
              elementProps.selfClose = config.void;
            }

            content.push(React.createElement(
              Element,
              elementProps,
              children || _this3.parseNode(nextNode, config)
            ));
          } else {
            content = content.concat(_this3.parseNode(nextNode, config.tagName ? config : parentConfig));
          }
        } else if (node.nodeType === TEXT_NODE) {
          var text = noHtml && !noHtmlExceptMatchers ? node.textContent : _this3.applyMatchers(node.textContent, parentConfig);

          if (Array.isArray(text)) {
            content = content.concat(text);
          } else {
            mergedText += text;
          }
        }
      });

      if (mergedText) {
        content.push(mergedText);
      }

      return content;
    }
  }]);

  return Parser;
}();

export default Parser;